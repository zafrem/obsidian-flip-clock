/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  VIEW_TYPE_FLIP_CLOCK: () => VIEW_TYPE_FLIP_CLOCK,
  default: () => FlipClockPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// audio-manager.ts
var AudioManager = class {
  constructor(volume = 0.5) {
    this.audioContext = null;
    this.volume = 0.5;
    this.volume = volume;
    this.initializeAudioContext();
  }
  initializeAudioContext() {
    try {
      if (typeof window !== "undefined" && (window.AudioContext || window.webkitAudioContext)) {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
    } catch (e) {
      console.error("Failed to initialize AudioContext:", e);
    }
  }
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(1, volume));
  }
  /**
   * Play a subtle tick sound
   */
  playTick() {
    if (!this.audioContext) {
      this.initializeAudioContext();
    }
    if (!this.audioContext)
      return;
    try {
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      oscillator.type = "sine";
      oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
      gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(this.volume * 0.1, this.audioContext.currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
      oscillator.start(this.audioContext.currentTime);
      oscillator.stop(this.audioContext.currentTime + 0.05);
    } catch (e) {
      console.error("Failed to play tick sound:", e);
    }
  }
  /**
   * Play an alarm sound
   */
  playAlarm() {
    if (!this.audioContext) {
      this.initializeAudioContext();
    }
    if (!this.audioContext)
      return;
    try {
      const playTone = (frequency, startTime, duration) => {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        oscillator.type = "sine";
        oscillator.frequency.setValueAtTime(frequency, startTime);
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, startTime + 0.05);
        gainNode.gain.linearRampToValueAtTime(this.volume * 0.2, startTime + duration - 0.1);
        gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
        oscillator.start(startTime);
        oscillator.stop(startTime + duration);
      };
      const currentTime = this.audioContext.currentTime;
      const noteDuration = 0.3;
      const gapDuration = 0.1;
      const melody = [
        { freq: 523.25, time: 0 },
        // C5
        { freq: 659.25, time: noteDuration + gapDuration },
        // E5
        { freq: 783.99, time: (noteDuration + gapDuration) * 2 }
        // G5
      ];
      melody.forEach((note) => {
        playTone(note.freq, currentTime + note.time, noteDuration);
      });
      melody.forEach((note) => {
        playTone(note.freq, currentTime + note.time + (noteDuration + gapDuration) * 3, noteDuration);
      });
    } catch (e) {
      console.error("Failed to play alarm sound:", e);
    }
  }
  /**
   * Play a flip mechanical sound
   */
  playFlip() {
    if (!this.audioContext) {
      this.initializeAudioContext();
    }
    if (!this.audioContext)
      return;
    try {
      const bufferSize = this.audioContext.sampleRate * 0.05;
      const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
      const output = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }
      const noise = this.audioContext.createBufferSource();
      noise.buffer = buffer;
      const filter = this.audioContext.createBiquadFilter();
      filter.type = "bandpass";
      filter.frequency.setValueAtTime(400, this.audioContext.currentTime);
      filter.Q.setValueAtTime(1, this.audioContext.currentTime);
      const gainNode = this.audioContext.createGain();
      noise.connect(filter);
      filter.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(this.volume * 0.05, this.audioContext.currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
      noise.start(this.audioContext.currentTime);
      noise.stop(this.audioContext.currentTime + 0.05);
    } catch (e) {
      console.error("Failed to play flip sound:", e);
    }
  }
  /**
   * Clean up resources
   */
  dispose() {
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }
  }
};

// main.ts
var VIEW_TYPE_FLIP_CLOCK = "flip-clock-view";
var DEFAULT_SETTINGS = {
  mode: "clock",
  use24Hour: true,
  showSeconds: true,
  animationEnabled: true,
  soundEnabled: false,
  tickSoundEnabled: false,
  alarmSoundEnabled: true,
  volume: 0.5,
  timerPresets: [300, 600, 1500, 3e3],
  // 5, 10, 25, 50 minutes
  persistTimerState: false,
  timerDuration: 1500,
  timerRemaining: 1500,
  timerLoop: false,
  blinkingColon: false,
  reduceMotion: false,
  highContrast: false
};
var FlipClockPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.audioManager = new AudioManager(this.settings.volume);
    this.registerView(
      VIEW_TYPE_FLIP_CLOCK,
      (leaf) => new FlipClockView(leaf, this)
    );
    this.addRibbonIcon("clock", "Open Flip Clock", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-flip-clock",
      name: "Open Flip Clock",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new FlipClockSettingTab(this.app, this));
    this.registerMarkdownCodeBlockProcessor("flipclock", this.processFlipClockCodeBlock.bind(this));
    console.log("Flip Clock plugin loaded");
  }
  onunload() {
    if (this.audioManager) {
      this.audioManager.dispose();
    }
    console.log("Flip Clock plugin unloaded");
  }
  processFlipClockCodeBlock(source, el, ctx) {
    const options = this.parseCodeBlockOptions(source);
    const container = el.createDiv("flip-clock-embed");
    const embedView = new FlipClockEmbedView(container, this, options);
    embedView.render();
  }
  parseCodeBlockOptions(source) {
    const options = {};
    const lines = source.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      const [key, value] = trimmed.split(":").map((s) => s.trim());
      if (!key || !value)
        continue;
      switch (key.toLowerCase()) {
        case "mode":
          if (value === "clock" || value === "timer") {
            options.mode = value;
          }
          break;
        case "format":
          options.use24Hour = value === "24h";
          break;
        case "seconds":
          options.showSeconds = value.toLowerCase() === "true";
          break;
        case "animation":
          options.animationEnabled = value.toLowerCase() === "true";
          break;
        case "timer":
          const duration = this.parseDuration(value);
          if (duration > 0) {
            options.timerDuration = duration;
            options.timerRemaining = duration;
          }
          break;
      }
    }
    return options;
  }
  parseDuration(value) {
    let totalSeconds = 0;
    const hourMatch = value.match(/(\d+)h/);
    const minMatch = value.match(/(\d+)m/);
    const secMatch = value.match(/(\d+)s/);
    if (hourMatch)
      totalSeconds += parseInt(hourMatch[1]) * 3600;
    if (minMatch)
      totalSeconds += parseInt(minMatch[1]) * 60;
    if (secMatch)
      totalSeconds += parseInt(secMatch[1]);
    return totalSeconds;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_FLIP_CLOCK);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_FLIP_CLOCK, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
var FlipClockView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.intervalId = null;
    this.timerIntervalId = null;
    this.timerRunning = false;
    this.timerPaused = false;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_FLIP_CLOCK;
  }
  getDisplayText() {
    return "Flip Clock";
  }
  getIcon() {
    return "clock";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("flip-clock-container");
    this.containerEl = container.createDiv("flip-clock-main");
    const modeSelector = this.containerEl.createDiv("flip-clock-mode-selector");
    const clockBtn = modeSelector.createEl("button", { text: "Clock" });
    const timerBtn = modeSelector.createEl("button", { text: "Timer" });
    clockBtn.addEventListener("click", async () => {
      this.plugin.settings.mode = "clock";
      await this.plugin.saveSettings();
      this.updateDisplay();
    });
    timerBtn.addEventListener("click", async () => {
      this.plugin.settings.mode = "timer";
      await this.plugin.saveSettings();
      this.updateDisplay();
    });
    this.clockEl = this.containerEl.createDiv("flip-clock-display");
    this.controlsEl = this.containerEl.createDiv("flip-clock-controls");
    this.updateDisplay();
  }
  async onClose() {
    if (this.intervalId !== null) {
      window.clearInterval(this.intervalId);
    }
    if (this.timerIntervalId !== null) {
      window.clearInterval(this.timerIntervalId);
    }
  }
  updateDisplay() {
    if (this.intervalId !== null) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
    }
    if (this.timerIntervalId !== null) {
      window.clearInterval(this.timerIntervalId);
      this.timerIntervalId = null;
    }
    if (this.plugin.settings.mode === "clock") {
      this.showClockMode();
    } else {
      this.showTimerMode();
    }
  }
  showClockMode() {
    this.clockEl.empty();
    this.controlsEl.empty();
    this.controlsEl.hide();
    const hoursDiv = this.createFlipDigitPair("hours");
    const colonDiv1 = this.clockEl.createDiv("flip-colon");
    colonDiv1.setText(":");
    const minutesDiv = this.createFlipDigitPair("minutes");
    const colonDiv2 = this.clockEl.createDiv("flip-colon");
    colonDiv2.setText(":");
    const secondsDiv = this.createFlipDigitPair("seconds");
    if (!this.plugin.settings.showSeconds) {
      colonDiv2.hide();
      secondsDiv.hide();
    }
    this.updateClock();
    this.intervalId = window.setInterval(() => this.updateClock(), 1e3);
  }
  showTimerMode() {
    this.clockEl.empty();
    this.controlsEl.empty();
    this.controlsEl.show();
    const hoursDiv = this.createFlipDigitPair("hours");
    const colonDiv1 = this.clockEl.createDiv("flip-colon");
    colonDiv1.setText(":");
    const minutesDiv = this.createFlipDigitPair("minutes");
    const colonDiv2 = this.clockEl.createDiv("flip-colon");
    colonDiv2.setText(":");
    const secondsDiv = this.createFlipDigitPair("seconds");
    const startBtn = this.controlsEl.createEl("button", { text: "Start", cls: "flip-clock-btn" });
    const pauseBtn = this.controlsEl.createEl("button", { text: "Pause", cls: "flip-clock-btn" });
    const resetBtn = this.controlsEl.createEl("button", { text: "Reset", cls: "flip-clock-btn" });
    pauseBtn.hide();
    startBtn.addEventListener("click", () => {
      this.startTimer();
      startBtn.hide();
      pauseBtn.show();
    });
    pauseBtn.addEventListener("click", () => {
      this.pauseTimer();
      pauseBtn.hide();
      startBtn.show();
      startBtn.setText("Resume");
    });
    resetBtn.addEventListener("click", () => {
      this.resetTimer();
      pauseBtn.hide();
      startBtn.show();
      startBtn.setText("Start");
    });
    const presetsDiv = this.controlsEl.createDiv("flip-clock-presets");
    for (const preset of this.plugin.settings.timerPresets) {
      const presetBtn = presetsDiv.createEl("button", {
        text: this.formatPresetTime(preset),
        cls: "flip-clock-preset-btn"
      });
      presetBtn.addEventListener("click", () => {
        this.plugin.settings.timerDuration = preset;
        this.plugin.settings.timerRemaining = preset;
        this.resetTimer();
      });
    }
    this.updateTimerDisplay();
  }
  createFlipDigitPair(id) {
    const container = this.clockEl.createDiv("flip-digit-pair");
    container.id = `flip-${id}`;
    const digit1 = container.createDiv("flip-digit");
    digit1.id = `${id}-1`;
    const card1 = digit1.createDiv("flip-card");
    const top1 = card1.createDiv("flip-card-top");
    const topSpan1 = top1.createEl("span");
    topSpan1.setText("0");
    const bottom1 = card1.createDiv("flip-card-bottom");
    const bottomSpan1 = bottom1.createEl("span");
    bottomSpan1.setText("0");
    const flipTop1 = card1.createDiv("flip-card-flip-top");
    flipTop1.createEl("span");
    const flipBottom1 = card1.createDiv("flip-card-flip-bottom");
    flipBottom1.createEl("span");
    const digit2 = container.createDiv("flip-digit");
    digit2.id = `${id}-2`;
    const card2 = digit2.createDiv("flip-card");
    const top2 = card2.createDiv("flip-card-top");
    const topSpan2 = top2.createEl("span");
    topSpan2.setText("0");
    const bottom2 = card2.createDiv("flip-card-bottom");
    const bottomSpan2 = bottom2.createEl("span");
    bottomSpan2.setText("0");
    const flipTop2 = card2.createDiv("flip-card-flip-top");
    flipTop2.createEl("span");
    const flipBottom2 = card2.createDiv("flip-card-flip-bottom");
    flipBottom2.createEl("span");
    return container;
  }
  updateClock() {
    const now = new Date();
    let hours = now.getHours();
    if (!this.plugin.settings.use24Hour && hours > 12) {
      hours -= 12;
    } else if (!this.plugin.settings.use24Hour && hours === 0) {
      hours = 12;
    }
    const minutes = now.getMinutes();
    const seconds = now.getSeconds();
    this.updateDigitPair("hours", hours);
    this.updateDigitPair("minutes", minutes);
    if (this.plugin.settings.showSeconds) {
      this.updateDigitPair("seconds", seconds);
    }
  }
  updateTimerDisplay() {
    const remaining = this.plugin.settings.timerRemaining;
    const hours = Math.floor(remaining / 3600);
    const minutes = Math.floor(remaining % 3600 / 60);
    const seconds = remaining % 60;
    this.updateDigitPair("hours", hours);
    this.updateDigitPair("minutes", minutes);
    this.updateDigitPair("seconds", seconds);
  }
  updateDigitPair(id, value) {
    const digit1 = Math.floor(value / 10);
    const digit2 = value % 10;
    this.updateDigit(`${id}-1`, digit1);
    this.updateDigit(`${id}-2`, digit2);
  }
  updateDigit(id, value) {
    const digitEl = this.containerEl.querySelector(`#${id}`);
    if (!digitEl)
      return;
    const top = digitEl.querySelector(".flip-card-top span");
    const bottom = digitEl.querySelector(".flip-card-bottom span");
    const flipTop = digitEl.querySelector(".flip-card-flip-top span");
    const flipBottom = digitEl.querySelector(".flip-card-flip-bottom span");
    if (top && bottom && flipTop && flipBottom) {
      const currentValue = top.textContent || "";
      const newValue = value.toString();
      if (top.textContent !== bottom.textContent) {
        top.textContent = newValue;
        bottom.textContent = newValue;
        return;
      }
      if (currentValue !== newValue) {
        if (currentValue !== "" && currentValue !== null && currentValue !== "0") {
          this.playTickSound();
        }
        if (this.plugin.settings.animationEnabled && !this.plugin.settings.reduceMotion && currentValue !== "" && currentValue !== null && currentValue !== "0") {
          flipTop.textContent = currentValue;
          flipBottom.textContent = newValue;
          const card = digitEl.querySelector(".flip-card");
          card == null ? void 0 : card.classList.add("flipping");
          setTimeout(() => {
            top.textContent = newValue;
            bottom.textContent = newValue;
            card == null ? void 0 : card.classList.remove("flipping");
          }, 600);
        } else {
          top.textContent = newValue;
          bottom.textContent = newValue;
        }
      } else {
        if (!top.textContent || !bottom.textContent) {
          top.textContent = newValue;
          bottom.textContent = newValue;
        }
      }
    }
  }
  startTimer() {
    if (this.timerRunning && !this.timerPaused)
      return;
    this.timerRunning = true;
    this.timerPaused = false;
    this.timerIntervalId = window.setInterval(() => {
      if (this.plugin.settings.timerRemaining > 0) {
        this.plugin.settings.timerRemaining--;
        this.updateTimerDisplay();
        if (this.plugin.settings.persistTimerState) {
          this.plugin.saveSettings();
        }
      } else {
        this.onTimerComplete();
      }
    }, 1e3);
  }
  pauseTimer() {
    this.timerPaused = true;
    if (this.timerIntervalId !== null) {
      window.clearInterval(this.timerIntervalId);
      this.timerIntervalId = null;
    }
  }
  resetTimer() {
    this.timerRunning = false;
    this.timerPaused = false;
    if (this.timerIntervalId !== null) {
      window.clearInterval(this.timerIntervalId);
      this.timerIntervalId = null;
    }
    this.plugin.settings.timerRemaining = this.plugin.settings.timerDuration;
    this.updateTimerDisplay();
    if (this.plugin.settings.persistTimerState) {
      this.plugin.saveSettings();
    }
  }
  onTimerComplete() {
    if (this.plugin.settings.soundEnabled && this.plugin.settings.alarmSoundEnabled) {
      this.playAlarmSound();
    }
    this.clockEl.addClass("timer-complete");
    setTimeout(() => {
      this.clockEl.removeClass("timer-complete");
    }, 2e3);
    if (this.plugin.settings.timerLoop) {
      this.resetTimer();
      this.startTimer();
    } else {
      this.pauseTimer();
      this.timerRunning = false;
    }
  }
  playAlarmSound() {
    if (this.plugin.audioManager) {
      this.plugin.audioManager.playAlarm();
    }
  }
  playTickSound() {
    if (this.plugin.audioManager && this.plugin.settings.soundEnabled && this.plugin.settings.tickSoundEnabled) {
      this.plugin.audioManager.playTick();
    }
  }
  formatPresetTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) {
      return `${minutes}m`;
    } else {
      const hours = Math.floor(minutes / 60);
      const remainingMinutes = minutes % 60;
      return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
    }
  }
};
var FlipClockEmbedView = class {
  constructor(container, plugin, options) {
    this.intervalId = null;
    this.clockEl = null;
    this.controlsEl = null;
    this.timerIntervalId = null;
    this.timerRunning = false;
    this.timerPaused = false;
    this.container = container;
    this.plugin = plugin;
    this.settings = Object.assign({}, plugin.settings, options);
  }
  render() {
    this.container.empty();
    this.clockEl = this.container.createDiv("flip-clock-display");
    if (this.settings.mode === "clock") {
      this.renderClock();
    } else {
      this.renderTimer();
    }
  }
  renderClock() {
    if (!this.clockEl)
      return;
    this.clockEl.empty();
    const hoursDiv = this.createFlipDigitPair("embed-hours");
    const colonDiv1 = this.clockEl.createDiv("flip-colon");
    colonDiv1.setText(":");
    const minutesDiv = this.createFlipDigitPair("embed-minutes");
    if (this.settings.showSeconds) {
      const colonDiv2 = this.clockEl.createDiv("flip-colon");
      colonDiv2.setText(":");
      const secondsDiv = this.createFlipDigitPair("embed-seconds");
    }
    this.updateClock();
    this.intervalId = window.setInterval(() => this.updateClock(), 1e3);
  }
  renderTimer() {
    if (!this.clockEl)
      return;
    this.clockEl.empty();
    const hoursDiv = this.createFlipDigitPair("embed-hours");
    const colonDiv1 = this.clockEl.createDiv("flip-colon");
    colonDiv1.setText(":");
    const minutesDiv = this.createFlipDigitPair("embed-minutes");
    const colonDiv2 = this.clockEl.createDiv("flip-colon");
    colonDiv2.setText(":");
    const secondsDiv = this.createFlipDigitPair("embed-seconds");
    this.controlsEl = this.container.createDiv("flip-clock-controls");
    const startBtn = this.controlsEl.createEl("button", { text: "Start", cls: "flip-clock-btn" });
    const pauseBtn = this.controlsEl.createEl("button", { text: "Pause", cls: "flip-clock-btn" });
    const resetBtn = this.controlsEl.createEl("button", { text: "Reset", cls: "flip-clock-btn" });
    pauseBtn.hide();
    startBtn.addEventListener("click", () => {
      this.startTimer();
      startBtn.hide();
      pauseBtn.show();
    });
    pauseBtn.addEventListener("click", () => {
      this.pauseTimer();
      pauseBtn.hide();
      startBtn.show();
      startBtn.setText("Resume");
    });
    resetBtn.addEventListener("click", () => {
      this.resetTimer();
      pauseBtn.hide();
      startBtn.show();
      startBtn.setText("Start");
    });
    this.updateTimerDisplay();
  }
  createFlipDigitPair(id) {
    if (!this.clockEl)
      return this.container.createDiv();
    const container = this.clockEl.createDiv("flip-digit-pair");
    container.id = `flip-${id}`;
    const digit1 = container.createDiv("flip-digit");
    digit1.id = `${id}-1`;
    const card1 = digit1.createDiv("flip-card");
    const top1 = card1.createDiv("flip-card-top");
    const topSpan1 = top1.createEl("span");
    topSpan1.setText("0");
    const bottom1 = card1.createDiv("flip-card-bottom");
    const bottomSpan1 = bottom1.createEl("span");
    bottomSpan1.setText("0");
    const flipTop1 = card1.createDiv("flip-card-flip-top");
    flipTop1.createEl("span");
    const flipBottom1 = card1.createDiv("flip-card-flip-bottom");
    flipBottom1.createEl("span");
    const digit2 = container.createDiv("flip-digit");
    digit2.id = `${id}-2`;
    const card2 = digit2.createDiv("flip-card");
    const top2 = card2.createDiv("flip-card-top");
    const topSpan2 = top2.createEl("span");
    topSpan2.setText("0");
    const bottom2 = card2.createDiv("flip-card-bottom");
    const bottomSpan2 = bottom2.createEl("span");
    bottomSpan2.setText("0");
    const flipTop2 = card2.createDiv("flip-card-flip-top");
    flipTop2.createEl("span");
    const flipBottom2 = card2.createDiv("flip-card-flip-bottom");
    flipBottom2.createEl("span");
    return container;
  }
  updateClock() {
    const now = new Date();
    let hours = now.getHours();
    if (!this.settings.use24Hour && hours > 12) {
      hours -= 12;
    } else if (!this.settings.use24Hour && hours === 0) {
      hours = 12;
    }
    const minutes = now.getMinutes();
    const seconds = now.getSeconds();
    this.updateDigitPair("embed-hours", hours);
    this.updateDigitPair("embed-minutes", minutes);
    if (this.settings.showSeconds) {
      this.updateDigitPair("embed-seconds", seconds);
    }
  }
  updateTimerDisplay() {
    const remaining = this.settings.timerRemaining;
    const hours = Math.floor(remaining / 3600);
    const minutes = Math.floor(remaining % 3600 / 60);
    const seconds = remaining % 60;
    this.updateDigitPair("embed-hours", hours);
    this.updateDigitPair("embed-minutes", minutes);
    this.updateDigitPair("embed-seconds", seconds);
  }
  updateDigitPair(id, value) {
    const digit1 = Math.floor(value / 10);
    const digit2 = value % 10;
    this.updateDigit(`${id}-1`, digit1);
    this.updateDigit(`${id}-2`, digit2);
  }
  updateDigit(id, value) {
    const digitEl = this.container.querySelector(`#${id}`);
    if (!digitEl)
      return;
    const top = digitEl.querySelector(".flip-card-top span");
    const bottom = digitEl.querySelector(".flip-card-bottom span");
    const flipTop = digitEl.querySelector(".flip-card-flip-top span");
    const flipBottom = digitEl.querySelector(".flip-card-flip-bottom span");
    if (top && bottom && flipTop && flipBottom) {
      const currentValue = top.textContent || "";
      const newValue = value.toString();
      if (top.textContent !== bottom.textContent) {
        top.textContent = newValue;
        bottom.textContent = newValue;
        return;
      }
      if (currentValue !== newValue) {
        if (this.settings.animationEnabled && !this.settings.reduceMotion && currentValue !== "" && currentValue !== null && currentValue !== "0") {
          flipTop.textContent = currentValue;
          flipBottom.textContent = newValue;
          const card = digitEl.querySelector(".flip-card");
          card == null ? void 0 : card.classList.add("flipping");
          setTimeout(() => {
            top.textContent = newValue;
            bottom.textContent = newValue;
            card == null ? void 0 : card.classList.remove("flipping");
          }, 600);
        } else {
          top.textContent = newValue;
          bottom.textContent = newValue;
        }
      } else {
        if (!top.textContent || !bottom.textContent) {
          top.textContent = newValue;
          bottom.textContent = newValue;
        }
      }
    }
  }
  startTimer() {
    if (this.timerRunning && !this.timerPaused)
      return;
    this.timerRunning = true;
    this.timerPaused = false;
    this.timerIntervalId = window.setInterval(() => {
      if (this.settings.timerRemaining > 0) {
        this.settings.timerRemaining--;
        this.updateTimerDisplay();
      } else {
        this.onTimerComplete();
      }
    }, 1e3);
  }
  pauseTimer() {
    this.timerPaused = true;
    if (this.timerIntervalId !== null) {
      window.clearInterval(this.timerIntervalId);
      this.timerIntervalId = null;
    }
  }
  resetTimer() {
    this.timerRunning = false;
    this.timerPaused = false;
    if (this.timerIntervalId !== null) {
      window.clearInterval(this.timerIntervalId);
      this.timerIntervalId = null;
    }
    this.settings.timerRemaining = this.settings.timerDuration;
    this.updateTimerDisplay();
  }
  onTimerComplete() {
    if (this.plugin.settings.soundEnabled && this.plugin.settings.alarmSoundEnabled) {
      this.plugin.audioManager.playAlarm();
    }
    if (this.clockEl) {
      this.clockEl.addClass("timer-complete");
      setTimeout(() => {
        var _a;
        (_a = this.clockEl) == null ? void 0 : _a.removeClass("timer-complete");
      }, 2e3);
    }
    if (this.settings.timerLoop) {
      this.resetTimer();
      this.startTimer();
    } else {
      this.pauseTimer();
      this.timerRunning = false;
    }
  }
  destroy() {
    if (this.intervalId !== null) {
      window.clearInterval(this.intervalId);
    }
    if (this.timerIntervalId !== null) {
      window.clearInterval(this.timerIntervalId);
    }
  }
};
var FlipClockSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Flip Clock Settings" });
    containerEl.createEl("h3", { text: "Clock Display" });
    new import_obsidian.Setting(containerEl).setName("24-hour format").setDesc("Use 24-hour time format instead of 12-hour").addToggle((toggle) => toggle.setValue(this.plugin.settings.use24Hour).onChange(async (value) => {
      this.plugin.settings.use24Hour = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show seconds").setDesc("Display seconds in the clock").addToggle((toggle) => toggle.setValue(this.plugin.settings.showSeconds).onChange(async (value) => {
      this.plugin.settings.showSeconds = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Blinking colon").setDesc("Make the colon blink every second").addToggle((toggle) => toggle.setValue(this.plugin.settings.blinkingColon).onChange(async (value) => {
      this.plugin.settings.blinkingColon = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Animation" });
    new import_obsidian.Setting(containerEl).setName("Enable animations").setDesc("Show flip animation when digits change").addToggle((toggle) => toggle.setValue(this.plugin.settings.animationEnabled).onChange(async (value) => {
      this.plugin.settings.animationEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Reduce motion").setDesc("Disable animations for accessibility").addToggle((toggle) => toggle.setValue(this.plugin.settings.reduceMotion).onChange(async (value) => {
      this.plugin.settings.reduceMotion = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Sound" });
    new import_obsidian.Setting(containerEl).setName("Enable sound").setDesc("Enable audio feedback").addToggle((toggle) => toggle.setValue(this.plugin.settings.soundEnabled).onChange(async (value) => {
      this.plugin.settings.soundEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Tick sound").setDesc("Play a tick sound on each second").addToggle((toggle) => toggle.setValue(this.plugin.settings.tickSoundEnabled).onChange(async (value) => {
      this.plugin.settings.tickSoundEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Alarm sound").setDesc("Play alarm when timer completes").addToggle((toggle) => toggle.setValue(this.plugin.settings.alarmSoundEnabled).onChange(async (value) => {
      this.plugin.settings.alarmSoundEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Volume").setDesc("Adjust sound volume").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.volume).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.volume = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Timer" });
    new import_obsidian.Setting(containerEl).setName("Loop timer").setDesc("Automatically restart timer when it completes").addToggle((toggle) => toggle.setValue(this.plugin.settings.timerLoop).onChange(async (value) => {
      this.plugin.settings.timerLoop = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Persist timer state").setDesc("Remember timer state after reloading Obsidian").addToggle((toggle) => toggle.setValue(this.plugin.settings.persistTimerState).onChange(async (value) => {
      this.plugin.settings.persistTimerState = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Accessibility" });
    new import_obsidian.Setting(containerEl).setName("High contrast").setDesc("Use high contrast colors for better visibility").addToggle((toggle) => toggle.setValue(this.plugin.settings.highContrast).onChange(async (value) => {
      this.plugin.settings.highContrast = value;
      await this.plugin.saveSettings();
    }));
  }
};
