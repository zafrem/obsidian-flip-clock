/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  VIEW_TYPE_FLIP_CLOCK: () => VIEW_TYPE_FLIP_CLOCK,
  default: () => FlipClockPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// audio-manager.ts
var AudioManager = class {
  constructor(volume = 0.5) {
    this.audioContext = null;
    this.volume = 0.5;
    this.volume = volume;
    this.initializeAudioContext();
  }
  initializeAudioContext() {
    try {
      if (globalThis.window !== void 0 && (globalThis.AudioContext || globalThis.webkitAudioContext)) {
        this.audioContext = new (globalThis.AudioContext || globalThis.webkitAudioContext)();
      }
    } catch (e) {
      console.error("Failed to initialize AudioContext:", e);
    }
  }
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(1, volume));
  }
  /**
   * Play a subtle tick sound
   */
  playTick() {
    if (!this.audioContext) {
      this.initializeAudioContext();
    }
    if (!this.audioContext)
      return;
    try {
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      oscillator.type = "sine";
      oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
      gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(this.volume * 0.1, this.audioContext.currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
      oscillator.start(this.audioContext.currentTime);
      oscillator.stop(this.audioContext.currentTime + 0.05);
    } catch (e) {
      console.error("Failed to play tick sound:", e);
    }
  }
  /**
   * Play an alarm sound
   */
  playAlarm() {
    if (!this.audioContext) {
      this.initializeAudioContext();
    }
    if (!this.audioContext)
      return;
    try {
      const playTone = (frequency, startTime, duration) => {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        oscillator.type = "sine";
        oscillator.frequency.setValueAtTime(frequency, startTime);
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, startTime + 0.05);
        gainNode.gain.linearRampToValueAtTime(this.volume * 0.2, startTime + duration - 0.1);
        gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
        oscillator.start(startTime);
        oscillator.stop(startTime + duration);
      };
      const currentTime = this.audioContext.currentTime;
      const noteDuration = 0.3;
      const gapDuration = 0.1;
      const melody = [
        { freq: 523.25, time: 0 },
        // C5
        { freq: 659.25, time: noteDuration + gapDuration },
        // E5
        { freq: 783.99, time: (noteDuration + gapDuration) * 2 }
        // G5
      ];
      melody.forEach((note) => {
        playTone(note.freq, currentTime + note.time, noteDuration);
      });
      melody.forEach((note) => {
        playTone(note.freq, currentTime + note.time + (noteDuration + gapDuration) * 3, noteDuration);
      });
    } catch (e) {
      console.error("Failed to play alarm sound:", e);
    }
  }
  /**
   * Play a flip mechanical sound
   */
  playFlip() {
    if (!this.audioContext) {
      this.initializeAudioContext();
    }
    if (!this.audioContext)
      return;
    try {
      const bufferSize = this.audioContext.sampleRate * 0.05;
      const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
      const output = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }
      const noise = this.audioContext.createBufferSource();
      noise.buffer = buffer;
      const filter = this.audioContext.createBiquadFilter();
      filter.type = "bandpass";
      filter.frequency.setValueAtTime(400, this.audioContext.currentTime);
      filter.Q.setValueAtTime(1, this.audioContext.currentTime);
      const gainNode = this.audioContext.createGain();
      noise.connect(filter);
      filter.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(this.volume * 0.05, this.audioContext.currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
      noise.start(this.audioContext.currentTime);
      noise.stop(this.audioContext.currentTime + 0.05);
    } catch (e) {
      console.error("Failed to play flip sound:", e);
    }
  }
  /**
   * Clean up resources
   */
  dispose() {
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }
  }
};

// main.ts
var VIEW_TYPE_FLIP_CLOCK = "flip-clock-view";
var DEFAULT_SETTINGS = {
  mode: "clock",
  use24Hour: true,
  showSeconds: false,
  animationEnabled: true,
  soundEnabled: false,
  tickSoundEnabled: false,
  alarmSoundEnabled: true,
  volume: 0.5,
  timerPresets: [300, 600, 1500, 3e3],
  // 5, 10, 25, 50 minutes
  persistTimerState: false,
  timerDuration: 1500,
  timerRemaining: 1500,
  timerLoop: false,
  blinkingColon: false,
  reduceMotion: false,
  highContrast: false,
  showInStatusBar: false,
  showFloatingClock: false,
  floatingClockPosition: null
};
var FlipClockPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.statusBarItem = null;
    this.statusBarClock = null;
    this.floatingClockEl = null;
    this.floatingClock = null;
  }
  async onload() {
    await this.loadSettings();
    this.audioManager = new AudioManager(this.settings.volume);
    this.registerView(
      VIEW_TYPE_FLIP_CLOCK,
      (leaf) => new FlipClockView(leaf, this)
    );
    this.addRibbonIcon("clock", "Open Flip Clock", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-flip-clock",
      name: "Open Flip Clock",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new FlipClockSettingTab(this.app, this));
    this.registerMarkdownCodeBlockProcessor("flipclock", this.processFlipClockCodeBlock.bind(this));
    if (this.settings.showInStatusBar) {
      this.setupStatusBar();
    }
    if (this.settings.showFloatingClock) {
      this.setupFloatingClock();
    }
    console.log("Flip Clock plugin loaded");
  }
  setupStatusBar() {
    if (!this.statusBarItem) {
      this.statusBarItem = this.addStatusBarItem();
      this.statusBarItem.addClass("flip-clock-status-bar");
    }
    if (!this.statusBarClock) {
      this.statusBarClock = new StatusBarClock(this.statusBarItem, this);
      this.statusBarClock.start();
    }
  }
  removeStatusBar() {
    if (this.statusBarClock) {
      this.statusBarClock.stop();
      this.statusBarClock = null;
    }
    if (this.statusBarItem) {
      this.statusBarItem.remove();
      this.statusBarItem = null;
    }
  }
  setupFloatingClock() {
    var _a;
    (_a = this.floatingClockEl) != null ? _a : this.floatingClockEl = document.body.createDiv("flip-clock-floating");
    if (!this.floatingClock) {
      this.floatingClock = new FloatingClock(this.floatingClockEl, this);
      this.floatingClock.start();
    }
  }
  removeFloatingClock() {
    if (this.floatingClock) {
      this.floatingClock.destroy();
      this.floatingClock = null;
    }
    if (this.floatingClockEl) {
      this.floatingClockEl.remove();
      this.floatingClockEl = null;
    }
  }
  onunload() {
    this.removeStatusBar();
    this.removeFloatingClock();
    if (this.audioManager) {
      this.audioManager.dispose();
    }
    console.log("Flip Clock plugin unloaded");
  }
  processFlipClockCodeBlock(source, el, ctx) {
    const options = this.parseCodeBlockOptions(source);
    const container = el.createDiv("flip-clock-embed");
    const embedView = new FlipClockEmbedView(container, this, options);
    embedView.render();
  }
  parseCodeBlockOptions(source) {
    const options = {};
    const lines = source.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      const [key, value] = trimmed.split(":").map((s) => s.trim());
      if (!key || !value)
        continue;
      switch (key.toLowerCase()) {
        case "mode":
          if (value === "clock" || value === "timer") {
            options.mode = value;
          }
          break;
        case "format":
          options.use24Hour = value === "24h";
          break;
        case "seconds":
          options.showSeconds = value.toLowerCase() === "true";
          break;
        case "animation":
          options.animationEnabled = value.toLowerCase() === "true";
          break;
        case "timer":
          const duration = this.parseDuration(value);
          if (duration > 0) {
            options.timerDuration = duration;
            options.timerRemaining = duration;
          }
          break;
      }
    }
    return options;
  }
  parseDuration(value) {
    let totalSeconds = 0;
    const hourMatch = /(\d+)h/.exec(value);
    const minMatch = /(\d+)m/.exec(value);
    const secMatch = /(\d+)s/.exec(value);
    if (hourMatch)
      totalSeconds += Number.parseInt(hourMatch[1]) * 3600;
    if (minMatch)
      totalSeconds += Number.parseInt(minMatch[1]) * 60;
    if (secMatch)
      totalSeconds += Number.parseInt(secMatch[1]);
    return totalSeconds;
  }
  async loadSettings() {
    this.settings = { ...DEFAULT_SETTINGS, ...await this.loadData() };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_FLIP_CLOCK);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_FLIP_CLOCK, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
var FloatingClock = class {
  constructor(container, plugin) {
    this.intervalId = null;
    this.isDragging = false;
    this.dragStartX = 0;
    this.dragStartY = 0;
    this.elementStartX = 0;
    this.elementStartY = 0;
    this.container = container;
    this.plugin = plugin;
    this.render();
    this.setupDragging();
    this.restorePosition();
  }
  render() {
    this.container.empty();
    const dragHandle = this.container.createDiv("flip-clock-floating-handle");
    dragHandle.innerHTML = "\u22EE\u22EE";
    dragHandle.title = "Drag to move";
    this.clockEl = this.container.createDiv("flip-clock-floating-display");
    this.createFlipDigitPair("floating-hours");
    const colonDiv1 = this.clockEl.createDiv("flip-colon-mini");
    colonDiv1.setText(":");
    this.createFlipDigitPair("floating-minutes");
    if (this.plugin.settings.showSeconds) {
      const colonDiv2 = this.clockEl.createDiv("flip-colon-mini");
      colonDiv2.setText(":");
      this.createFlipDigitPair("floating-seconds");
    }
    this.updateTime();
  }
  createFlipDigitPair(id) {
    const container = this.clockEl.createDiv("flip-digit-pair-mini");
    container.id = `flip-${id}`;
    for (let i = 1; i <= 2; i++) {
      const digit = container.createDiv("flip-digit-mini");
      digit.id = `${id}-${i}`;
      const card = digit.createDiv("flip-card-mini");
      const top = card.createDiv("flip-card-top-mini");
      const topSpan = top.createEl("span");
      topSpan.setText("0");
      const bottom = card.createDiv("flip-card-bottom-mini");
      const bottomSpan = bottom.createEl("span");
      bottomSpan.setText("0");
      const flipTop = card.createDiv("flip-card-flip-top-mini");
      flipTop.createEl("span");
      const flipBottom = card.createDiv("flip-card-flip-bottom-mini");
      flipBottom.createEl("span");
    }
    return container;
  }
  setupDragging() {
    const handleMouseDown = (e) => {
      this.isDragging = true;
      this.dragStartX = e.clientX;
      this.dragStartY = e.clientY;
      const rect = this.container.getBoundingClientRect();
      this.elementStartX = rect.left;
      this.elementStartY = rect.top;
      this.container.addClass("dragging");
      e.preventDefault();
    };
    const handleMouseMove = (e) => {
      if (!this.isDragging)
        return;
      const deltaX = e.clientX - this.dragStartX;
      const deltaY = e.clientY - this.dragStartY;
      const newX = this.elementStartX + deltaX;
      const newY = this.elementStartY + deltaY;
      this.container.style.left = `${newX}px`;
      this.container.style.top = `${newY}px`;
      this.container.style.transform = "none";
    };
    const handleMouseUp = () => {
      if (this.isDragging) {
        this.isDragging = false;
        this.container.removeClass("dragging");
        this.savePosition();
      }
    };
    this.container.addEventListener("mousedown", handleMouseDown);
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    this.container.dataset.cleanupDrag = "true";
  }
  restorePosition() {
    if (this.plugin.settings.floatingClockPosition) {
      const { x, y } = this.plugin.settings.floatingClockPosition;
      this.container.style.left = `${x}px`;
      this.container.style.top = `${y}px`;
      this.container.style.transform = "none";
    } else {
      this.container.style.left = "50%";
      this.container.style.top = "16px";
      this.container.style.transform = "translateX(-50%)";
    }
  }
  savePosition() {
    const rect = this.container.getBoundingClientRect();
    this.plugin.settings.floatingClockPosition = {
      x: rect.left,
      y: rect.top
    };
    this.plugin.saveSettings();
  }
  start() {
    var _a;
    (_a = this.intervalId) != null ? _a : this.intervalId = globalThis.setInterval(() => this.updateTime(), 1e3);
  }
  stop() {
    if (this.intervalId !== null) {
      globalThis.clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  destroy() {
    this.stop();
  }
  updateTime() {
    const now = new Date();
    let hours = now.getHours();
    if (!this.plugin.settings.use24Hour) {
      if (hours > 12) {
        hours -= 12;
      } else if (hours === 0) {
        hours = 12;
      }
    }
    const minutes = now.getMinutes();
    const seconds = now.getSeconds();
    this.updateDigitPair("floating-hours", hours);
    this.updateDigitPair("floating-minutes", minutes);
    if (this.plugin.settings.showSeconds) {
      this.updateDigitPair("floating-seconds", seconds);
    }
  }
  updateDigitPair(id, value) {
    const digit1 = Math.floor(value / 10);
    const digit2 = value % 10;
    this.updateDigit(`${id}-1`, digit1);
    this.updateDigit(`${id}-2`, digit2);
  }
  updateDigit(id, value) {
    const digitEl = this.container.querySelector(`#${id}`);
    if (!digitEl)
      return;
    const top = digitEl.querySelector(".flip-card-top-mini span");
    const bottom = digitEl.querySelector(".flip-card-bottom-mini span");
    const flipTop = digitEl.querySelector(".flip-card-flip-top-mini span");
    const flipBottom = digitEl.querySelector(".flip-card-flip-bottom-mini span");
    if (top && bottom && flipTop && flipBottom) {
      const currentValue = top.textContent || "";
      const newValue = value.toString();
      if (top.textContent !== bottom.textContent) {
        top.textContent = newValue;
        bottom.textContent = newValue;
        return;
      }
      if (currentValue === newValue) {
        if (!top.textContent || !bottom.textContent) {
          top.textContent = newValue;
          bottom.textContent = newValue;
        }
        return;
      }
      if (this.plugin.settings.animationEnabled && !this.plugin.settings.reduceMotion && currentValue && currentValue !== null) {
        flipTop.textContent = currentValue;
        flipBottom.textContent = newValue;
        const card = digitEl.querySelector(".flip-card-mini");
        card == null ? void 0 : card.classList.add("flipping");
        setTimeout(() => {
          bottom.textContent = newValue;
        }, 300);
        setTimeout(() => {
          top.textContent = newValue;
          card == null ? void 0 : card.classList.remove("flipping");
        }, 600);
      } else {
        top.textContent = newValue;
        bottom.textContent = newValue;
      }
    }
  }
};
var StatusBarClock = class {
  constructor(container, plugin) {
    this.intervalId = null;
    this.container = container;
    this.plugin = plugin;
    this.render();
  }
  render() {
    this.container.empty();
    this.container.addClass("flip-clock-status-bar-container");
    this.updateTime();
  }
  start() {
    var _a;
    (_a = this.intervalId) != null ? _a : this.intervalId = globalThis.setInterval(() => this.updateTime(), 1e3);
  }
  stop() {
    if (this.intervalId !== null) {
      globalThis.clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  updateTime() {
    const now = new Date();
    let hours = now.getHours();
    if (!this.plugin.settings.use24Hour) {
      if (hours > 12) {
        hours -= 12;
      } else if (hours === 0) {
        hours = 12;
      }
    }
    const minutes = now.getMinutes();
    const seconds = now.getSeconds();
    const hoursStr = String(hours).padStart(2, "0");
    const minutesStr = String(minutes).padStart(2, "0");
    const secondsStr = String(seconds).padStart(2, "0");
    if (this.plugin.settings.showSeconds) {
      this.container.setText(`${hoursStr}:${minutesStr}:${secondsStr}`);
    } else {
      this.container.setText(`${hoursStr}:${minutesStr}`);
    }
  }
};
var FlipClockView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.resizeObserver = null;
    this.intervalId = null;
    this.timerIntervalId = null;
    this.timerRunning = false;
    this.timerPaused = false;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_FLIP_CLOCK;
  }
  getDisplayText() {
    return "Flip Clock";
  }
  getIcon() {
    return "clock";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("flip-clock-container");
    this.containerEl = container.createDiv("flip-clock-main");
    const toolbar = this.containerEl.createDiv("flip-clock-toolbar");
    const modeSelector = toolbar.createDiv("flip-clock-mode-selector");
    const clockBtn = modeSelector.createEl("button", { text: "Clock" });
    const timerBtn = modeSelector.createEl("button", { text: "Timer" });
    clockBtn.addEventListener("click", async () => {
      this.plugin.settings.mode = "clock";
      await this.plugin.saveSettings();
      this.updateDisplay();
    });
    timerBtn.addEventListener("click", async () => {
      this.plugin.settings.mode = "timer";
      await this.plugin.saveSettings();
      this.updateDisplay();
    });
    const secondsControl = toolbar.createDiv("flip-clock-seconds-control");
    const secondsCheckbox = secondsControl.createEl("input", { type: "checkbox" });
    secondsCheckbox.id = "show-seconds-checkbox";
    secondsCheckbox.checked = this.plugin.settings.showSeconds;
    const secondsLabel = secondsControl.createEl("label", { text: "Show seconds" });
    secondsLabel.htmlFor = "show-seconds-checkbox";
    secondsCheckbox.addEventListener("change", async () => {
      this.plugin.settings.showSeconds = secondsCheckbox.checked;
      await this.plugin.saveSettings();
      this.updateDisplay();
    });
    this.displayWrapper = this.containerEl.createDiv("flip-clock-display-wrapper");
    this.clockEl = this.displayWrapper.createDiv("flip-clock-display");
    this.controlsEl = this.containerEl.createDiv("flip-clock-controls");
    this.updateDisplay();
    this.setupResponsiveSize();
  }
  async onClose() {
    if (this.intervalId !== null) {
      globalThis.clearInterval(this.intervalId);
    }
    if (this.timerIntervalId !== null) {
      globalThis.clearInterval(this.timerIntervalId);
    }
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
  }
  setupResponsiveSize() {
    if (!this.displayWrapper)
      return;
    this.resizeObserver = new ResizeObserver(() => {
      this.calculateResponsiveSize();
    });
    this.resizeObserver.observe(this.displayWrapper);
    this.calculateResponsiveSize();
  }
  calculateResponsiveSize() {
    if (!this.displayWrapper || !this.clockEl)
      return;
    const wrapperRect = this.displayWrapper.getBoundingClientRect();
    const availableWidth = wrapperRect.width;
    const availableHeight = wrapperRect.height;
    const digitPairCount = this.plugin.settings.showSeconds ? 3 : 2;
    const colonCount = this.plugin.settings.showSeconds ? 2 : 1;
    const baseDigitWidth = 80;
    const baseDigitHeight = 110;
    const baseGapBetweenDigits = 8;
    const baseGapBetweenPairs = 15;
    const baseColonWidth = 30;
    const totalDigitWidth = digitPairCount * 2 * baseDigitWidth + digitPairCount * baseGapBetweenDigits;
    const totalColonWidth = colonCount * baseColonWidth;
    const totalGapWidth = (digitPairCount - 1) * baseGapBetweenPairs;
    const totalBaseWidth = totalDigitWidth + totalColonWidth + totalGapWidth;
    const scaleByWidth = availableWidth * 0.9 / totalBaseWidth;
    const scaleByHeight = availableHeight * 0.7 / baseDigitHeight;
    const scale = Math.min(scaleByWidth, scaleByHeight, 2);
    const finalScale = Math.max(scale, 0.3);
    this.clockEl.style.transform = `scale(${finalScale})`;
  }
  updateDisplay() {
    if (this.intervalId !== null) {
      globalThis.clearInterval(this.intervalId);
      this.intervalId = null;
    }
    if (this.timerIntervalId !== null) {
      globalThis.clearInterval(this.timerIntervalId);
      this.timerIntervalId = null;
    }
    if (this.plugin.settings.mode === "clock") {
      this.showClockMode();
    } else {
      this.showTimerMode();
    }
    setTimeout(() => {
      this.calculateResponsiveSize();
    }, 10);
  }
  showClockMode() {
    this.clockEl.empty();
    this.controlsEl.empty();
    this.controlsEl.hide();
    this.createFlipDigitPair("hours");
    const colonDiv1 = this.clockEl.createDiv("flip-colon");
    colonDiv1.setText(":");
    if (this.plugin.settings.blinkingColon) {
      colonDiv1.addClass("blinking");
    }
    this.createFlipDigitPair("minutes");
    const colonDiv2 = this.clockEl.createDiv("flip-colon");
    colonDiv2.setText(":");
    if (this.plugin.settings.blinkingColon) {
      colonDiv2.addClass("blinking");
    }
    const secondsDiv = this.createFlipDigitPair("seconds");
    if (!this.plugin.settings.showSeconds) {
      colonDiv2.hide();
      secondsDiv.hide();
    }
    this.updateClock();
    this.intervalId = globalThis.setInterval(() => this.updateClock(), 1e3);
  }
  showTimerMode() {
    this.clockEl.empty();
    this.controlsEl.empty();
    this.controlsEl.show();
    this.createFlipDigitPair("hours");
    const colonDiv1 = this.clockEl.createDiv("flip-colon");
    colonDiv1.setText(":");
    if (this.plugin.settings.blinkingColon) {
      colonDiv1.addClass("blinking");
    }
    this.createFlipDigitPair("minutes");
    const colonDiv2 = this.clockEl.createDiv("flip-colon");
    colonDiv2.setText(":");
    if (this.plugin.settings.blinkingColon) {
      colonDiv2.addClass("blinking");
    }
    this.createFlipDigitPair("seconds");
    const startBtn = this.controlsEl.createEl("button", { text: "Start", cls: "flip-clock-btn" });
    const pauseBtn = this.controlsEl.createEl("button", { text: "Pause", cls: "flip-clock-btn" });
    const resetBtn = this.controlsEl.createEl("button", { text: "Reset", cls: "flip-clock-btn" });
    pauseBtn.hide();
    startBtn.addEventListener("click", () => {
      this.startTimer();
      startBtn.hide();
      pauseBtn.show();
    });
    pauseBtn.addEventListener("click", () => {
      this.pauseTimer();
      pauseBtn.hide();
      startBtn.show();
      startBtn.setText("Resume");
    });
    resetBtn.addEventListener("click", () => {
      this.resetTimer();
      pauseBtn.hide();
      startBtn.show();
      startBtn.setText("Start");
    });
    const presetsDiv = this.controlsEl.createDiv("flip-clock-presets");
    for (const preset of this.plugin.settings.timerPresets) {
      const presetBtn = presetsDiv.createEl("button", {
        text: this.formatPresetTime(preset),
        cls: "flip-clock-preset-btn"
      });
      presetBtn.addEventListener("click", () => {
        this.plugin.settings.timerDuration = preset;
        this.plugin.settings.timerRemaining = preset;
        this.resetTimer();
      });
    }
    this.updateTimerDisplay();
  }
  createFlipDigitPair(id) {
    const container = this.clockEl.createDiv("flip-digit-pair");
    container.id = `flip-${id}`;
    const digit1 = container.createDiv("flip-digit");
    digit1.id = `${id}-1`;
    const card1 = digit1.createDiv("flip-card");
    const top1 = card1.createDiv("flip-card-top");
    const topSpan1 = top1.createEl("span");
    topSpan1.setText("0");
    const bottom1 = card1.createDiv("flip-card-bottom");
    const bottomSpan1 = bottom1.createEl("span");
    bottomSpan1.setText("0");
    const flipTop1 = card1.createDiv("flip-card-flip-top");
    flipTop1.createEl("span");
    const flipBottom1 = card1.createDiv("flip-card-flip-bottom");
    flipBottom1.createEl("span");
    const digit2 = container.createDiv("flip-digit");
    digit2.id = `${id}-2`;
    const card2 = digit2.createDiv("flip-card");
    const top2 = card2.createDiv("flip-card-top");
    const topSpan2 = top2.createEl("span");
    topSpan2.setText("0");
    const bottom2 = card2.createDiv("flip-card-bottom");
    const bottomSpan2 = bottom2.createEl("span");
    bottomSpan2.setText("0");
    const flipTop2 = card2.createDiv("flip-card-flip-top");
    flipTop2.createEl("span");
    const flipBottom2 = card2.createDiv("flip-card-flip-bottom");
    flipBottom2.createEl("span");
    return container;
  }
  updateClock() {
    const now = new Date();
    let hours = now.getHours();
    if (!this.plugin.settings.use24Hour) {
      if (hours > 12) {
        hours -= 12;
      } else if (hours === 0) {
        hours = 12;
      }
    }
    const minutes = now.getMinutes();
    const seconds = now.getSeconds();
    this.updateDigitPair("hours", hours);
    this.updateDigitPair("minutes", minutes);
    if (this.plugin.settings.showSeconds) {
      this.updateDigitPair("seconds", seconds);
    }
  }
  updateTimerDisplay() {
    const remaining = this.plugin.settings.timerRemaining;
    const hours = Math.floor(remaining / 3600);
    const minutes = Math.floor(remaining % 3600 / 60);
    const seconds = remaining % 60;
    this.updateDigitPair("hours", hours);
    this.updateDigitPair("minutes", minutes);
    this.updateDigitPair("seconds", seconds);
  }
  updateDigitPair(id, value) {
    const digit1 = Math.floor(value / 10);
    const digit2 = value % 10;
    this.updateDigit(`${id}-1`, digit1);
    this.updateDigit(`${id}-2`, digit2);
  }
  updateDigit(id, value) {
    const digitEl = this.containerEl.querySelector(`#${id}`);
    if (!digitEl)
      return;
    const top = digitEl.querySelector(".flip-card-top span");
    const bottom = digitEl.querySelector(".flip-card-bottom span");
    const flipTop = digitEl.querySelector(".flip-card-flip-top span");
    const flipBottom = digitEl.querySelector(".flip-card-flip-bottom span");
    if (top && bottom && flipTop && flipBottom) {
      const currentValue = top.textContent || "";
      const newValue = value.toString();
      if (top.textContent !== bottom.textContent) {
        top.textContent = newValue;
        bottom.textContent = newValue;
        return;
      }
      if (currentValue === newValue) {
        if (!top.textContent || !bottom.textContent) {
          top.textContent = newValue;
          bottom.textContent = newValue;
        }
        return;
      }
      if (currentValue && currentValue !== null) {
        this.playTickSound();
      }
      if (this.plugin.settings.animationEnabled && !this.plugin.settings.reduceMotion && currentValue && currentValue !== null) {
        flipTop.textContent = currentValue;
        flipBottom.textContent = newValue;
        const card = digitEl.querySelector(".flip-card");
        card == null ? void 0 : card.classList.add("flipping");
        setTimeout(() => {
          bottom.textContent = newValue;
        }, 300);
        setTimeout(() => {
          top.textContent = newValue;
          card == null ? void 0 : card.classList.remove("flipping");
        }, 600);
      } else {
        top.textContent = newValue;
        bottom.textContent = newValue;
      }
    }
  }
  startTimer() {
    if (this.timerRunning && !this.timerPaused)
      return;
    this.timerRunning = true;
    this.timerPaused = false;
    this.timerIntervalId = globalThis.setInterval(() => {
      if (this.plugin.settings.timerRemaining > 0) {
        this.plugin.settings.timerRemaining--;
        this.updateTimerDisplay();
        if (this.plugin.settings.persistTimerState) {
          this.plugin.saveSettings();
        }
      } else {
        this.onTimerComplete();
      }
    }, 1e3);
  }
  pauseTimer() {
    this.timerPaused = true;
    if (this.timerIntervalId !== null) {
      globalThis.clearInterval(this.timerIntervalId);
      this.timerIntervalId = null;
    }
  }
  resetTimer() {
    this.timerRunning = false;
    this.timerPaused = false;
    if (this.timerIntervalId !== null) {
      globalThis.clearInterval(this.timerIntervalId);
      this.timerIntervalId = null;
    }
    this.plugin.settings.timerRemaining = this.plugin.settings.timerDuration;
    this.updateTimerDisplay();
    if (this.plugin.settings.persistTimerState) {
      this.plugin.saveSettings();
    }
  }
  onTimerComplete() {
    if (this.plugin.settings.soundEnabled && this.plugin.settings.alarmSoundEnabled) {
      this.playAlarmSound();
    }
    this.clockEl.addClass("timer-complete");
    setTimeout(() => {
      this.clockEl.removeClass("timer-complete");
    }, 2e3);
    if (this.plugin.settings.timerLoop) {
      this.resetTimer();
      this.startTimer();
    } else {
      this.pauseTimer();
      this.timerRunning = false;
    }
  }
  playAlarmSound() {
    if (this.plugin.audioManager) {
      this.plugin.audioManager.playAlarm();
    }
  }
  playTickSound() {
    if (this.plugin.audioManager && this.plugin.settings.soundEnabled && this.plugin.settings.tickSoundEnabled) {
      this.plugin.audioManager.playTick();
    }
  }
  formatPresetTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) {
      return `${minutes}m`;
    } else {
      const hours = Math.floor(minutes / 60);
      const remainingMinutes = minutes % 60;
      return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
    }
  }
};
var FlipClockEmbedView = class {
  constructor(container, plugin, options) {
    this.displayWrapper = null;
    this.resizeObserver = null;
    this.intervalId = null;
    this.clockEl = null;
    this.controlsEl = null;
    this.timerIntervalId = null;
    this.timerRunning = false;
    this.timerPaused = false;
    this.container = container;
    this.plugin = plugin;
    this.settings = { ...plugin.settings, ...options };
  }
  render() {
    this.container.empty();
    this.displayWrapper = this.container.createDiv("flip-clock-display-wrapper");
    this.clockEl = this.displayWrapper.createDiv("flip-clock-display");
    if (this.settings.mode === "clock") {
      this.renderClock();
    } else {
      this.renderTimer();
    }
    this.setupResponsiveSize();
  }
  renderClock() {
    if (!this.clockEl)
      return;
    this.clockEl.empty();
    this.createFlipDigitPair("embed-hours");
    const colonDiv1 = this.clockEl.createDiv("flip-colon");
    colonDiv1.setText(":");
    if (this.settings.blinkingColon) {
      colonDiv1.addClass("blinking");
    }
    this.createFlipDigitPair("embed-minutes");
    if (this.settings.showSeconds) {
      const colonDiv2 = this.clockEl.createDiv("flip-colon");
      colonDiv2.setText(":");
      if (this.settings.blinkingColon) {
        colonDiv2.addClass("blinking");
      }
      this.createFlipDigitPair("embed-seconds");
    }
    this.updateClock();
    this.intervalId = globalThis.setInterval(() => this.updateClock(), 1e3);
  }
  renderTimer() {
    if (!this.clockEl)
      return;
    this.clockEl.empty();
    this.createFlipDigitPair("embed-hours");
    const colonDiv1 = this.clockEl.createDiv("flip-colon");
    colonDiv1.setText(":");
    if (this.settings.blinkingColon) {
      colonDiv1.addClass("blinking");
    }
    this.createFlipDigitPair("embed-minutes");
    const colonDiv2 = this.clockEl.createDiv("flip-colon");
    colonDiv2.setText(":");
    if (this.settings.blinkingColon) {
      colonDiv2.addClass("blinking");
    }
    this.createFlipDigitPair("embed-seconds");
    this.controlsEl = this.container.createDiv("flip-clock-controls");
    const startBtn = this.controlsEl.createEl("button", { text: "Start", cls: "flip-clock-btn" });
    const pauseBtn = this.controlsEl.createEl("button", { text: "Pause", cls: "flip-clock-btn" });
    const resetBtn = this.controlsEl.createEl("button", { text: "Reset", cls: "flip-clock-btn" });
    pauseBtn.hide();
    startBtn.addEventListener("click", () => {
      this.startTimer();
      startBtn.hide();
      pauseBtn.show();
    });
    pauseBtn.addEventListener("click", () => {
      this.pauseTimer();
      pauseBtn.hide();
      startBtn.show();
      startBtn.setText("Resume");
    });
    resetBtn.addEventListener("click", () => {
      this.resetTimer();
      pauseBtn.hide();
      startBtn.show();
      startBtn.setText("Start");
    });
    this.updateTimerDisplay();
  }
  createFlipDigitPair(id) {
    if (!this.clockEl)
      return this.container.createDiv();
    const container = this.clockEl.createDiv("flip-digit-pair");
    container.id = `flip-${id}`;
    const digit1 = container.createDiv("flip-digit");
    digit1.id = `${id}-1`;
    const card1 = digit1.createDiv("flip-card");
    const top1 = card1.createDiv("flip-card-top");
    const topSpan1 = top1.createEl("span");
    topSpan1.setText("0");
    const bottom1 = card1.createDiv("flip-card-bottom");
    const bottomSpan1 = bottom1.createEl("span");
    bottomSpan1.setText("0");
    const flipTop1 = card1.createDiv("flip-card-flip-top");
    flipTop1.createEl("span");
    const flipBottom1 = card1.createDiv("flip-card-flip-bottom");
    flipBottom1.createEl("span");
    const digit2 = container.createDiv("flip-digit");
    digit2.id = `${id}-2`;
    const card2 = digit2.createDiv("flip-card");
    const top2 = card2.createDiv("flip-card-top");
    const topSpan2 = top2.createEl("span");
    topSpan2.setText("0");
    const bottom2 = card2.createDiv("flip-card-bottom");
    const bottomSpan2 = bottom2.createEl("span");
    bottomSpan2.setText("0");
    const flipTop2 = card2.createDiv("flip-card-flip-top");
    flipTop2.createEl("span");
    const flipBottom2 = card2.createDiv("flip-card-flip-bottom");
    flipBottom2.createEl("span");
    return container;
  }
  updateClock() {
    const now = new Date();
    let hours = now.getHours();
    if (!this.settings.use24Hour) {
      if (hours > 12) {
        hours -= 12;
      } else if (hours === 0) {
        hours = 12;
      }
    }
    const minutes = now.getMinutes();
    const seconds = now.getSeconds();
    this.updateDigitPair("embed-hours", hours);
    this.updateDigitPair("embed-minutes", minutes);
    if (this.settings.showSeconds) {
      this.updateDigitPair("embed-seconds", seconds);
    }
  }
  updateTimerDisplay() {
    const remaining = this.settings.timerRemaining;
    const hours = Math.floor(remaining / 3600);
    const minutes = Math.floor(remaining % 3600 / 60);
    const seconds = remaining % 60;
    this.updateDigitPair("embed-hours", hours);
    this.updateDigitPair("embed-minutes", minutes);
    this.updateDigitPair("embed-seconds", seconds);
  }
  updateDigitPair(id, value) {
    const digit1 = Math.floor(value / 10);
    const digit2 = value % 10;
    this.updateDigit(`${id}-1`, digit1);
    this.updateDigit(`${id}-2`, digit2);
  }
  updateDigit(id, value) {
    const digitEl = this.container.querySelector(`#${id}`);
    if (!digitEl)
      return;
    const top = digitEl.querySelector(".flip-card-top span");
    const bottom = digitEl.querySelector(".flip-card-bottom span");
    const flipTop = digitEl.querySelector(".flip-card-flip-top span");
    const flipBottom = digitEl.querySelector(".flip-card-flip-bottom span");
    if (top && bottom && flipTop && flipBottom) {
      const currentValue = top.textContent || "";
      const newValue = value.toString();
      if (top.textContent !== bottom.textContent) {
        top.textContent = newValue;
        bottom.textContent = newValue;
        return;
      }
      if (currentValue === newValue) {
        if (!top.textContent || !bottom.textContent) {
          top.textContent = newValue;
          bottom.textContent = newValue;
        }
        return;
      }
      if (this.settings.animationEnabled && !this.settings.reduceMotion && currentValue && currentValue !== null) {
        flipTop.textContent = currentValue;
        flipBottom.textContent = newValue;
        const card = digitEl.querySelector(".flip-card");
        card == null ? void 0 : card.classList.add("flipping");
        setTimeout(() => {
          bottom.textContent = newValue;
        }, 300);
        setTimeout(() => {
          top.textContent = newValue;
          card == null ? void 0 : card.classList.remove("flipping");
        }, 600);
      } else {
        top.textContent = newValue;
        bottom.textContent = newValue;
      }
    }
  }
  startTimer() {
    if (this.timerRunning && !this.timerPaused)
      return;
    this.timerRunning = true;
    this.timerPaused = false;
    this.timerIntervalId = globalThis.setInterval(() => {
      if (this.settings.timerRemaining > 0) {
        this.settings.timerRemaining--;
        this.updateTimerDisplay();
      } else {
        this.onTimerComplete();
      }
    }, 1e3);
  }
  pauseTimer() {
    this.timerPaused = true;
    if (this.timerIntervalId !== null) {
      globalThis.clearInterval(this.timerIntervalId);
      this.timerIntervalId = null;
    }
  }
  resetTimer() {
    this.timerRunning = false;
    this.timerPaused = false;
    if (this.timerIntervalId !== null) {
      globalThis.clearInterval(this.timerIntervalId);
      this.timerIntervalId = null;
    }
    this.settings.timerRemaining = this.settings.timerDuration;
    this.updateTimerDisplay();
  }
  onTimerComplete() {
    if (this.plugin.settings.soundEnabled && this.plugin.settings.alarmSoundEnabled) {
      this.plugin.audioManager.playAlarm();
    }
    if (this.clockEl) {
      this.clockEl.addClass("timer-complete");
      setTimeout(() => {
        var _a;
        (_a = this.clockEl) == null ? void 0 : _a.removeClass("timer-complete");
      }, 2e3);
    }
    if (this.settings.timerLoop) {
      this.resetTimer();
      this.startTimer();
    } else {
      this.pauseTimer();
      this.timerRunning = false;
    }
  }
  setupResponsiveSize() {
    if (!this.displayWrapper)
      return;
    this.resizeObserver = new ResizeObserver(() => {
      this.calculateResponsiveSize();
    });
    this.resizeObserver.observe(this.displayWrapper);
    this.calculateResponsiveSize();
  }
  calculateResponsiveSize() {
    if (!this.displayWrapper || !this.clockEl)
      return;
    const wrapperRect = this.displayWrapper.getBoundingClientRect();
    const availableWidth = wrapperRect.width;
    const availableHeight = wrapperRect.height;
    const digitPairCount = this.settings.showSeconds ? 3 : 2;
    const colonCount = this.settings.showSeconds ? 2 : 1;
    const baseDigitWidth = 80;
    const baseDigitHeight = 110;
    const baseGapBetweenDigits = 8;
    const baseGapBetweenPairs = 15;
    const baseColonWidth = 30;
    const totalDigitWidth = digitPairCount * 2 * baseDigitWidth + digitPairCount * baseGapBetweenDigits;
    const totalColonWidth = colonCount * baseColonWidth;
    const totalGapWidth = (digitPairCount - 1) * baseGapBetweenPairs;
    const totalBaseWidth = totalDigitWidth + totalColonWidth + totalGapWidth;
    const scaleByWidth = availableWidth * 0.9 / totalBaseWidth;
    const scaleByHeight = availableHeight * 0.8 / baseDigitHeight;
    const scale = Math.min(scaleByWidth, scaleByHeight, 1.5);
    const finalScale = Math.max(scale, 0.3);
    this.clockEl.style.transform = `scale(${finalScale})`;
  }
  destroy() {
    if (this.intervalId !== null) {
      globalThis.clearInterval(this.intervalId);
    }
    if (this.timerIntervalId !== null) {
      globalThis.clearInterval(this.timerIntervalId);
    }
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
  }
};
var FlipClockSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Flip Clock Settings" });
    containerEl.createEl("h3", { text: "Clock Display" });
    new import_obsidian.Setting(containerEl).setName("24-hour format").setDesc("Use 24-hour time format instead of 12-hour").addToggle((toggle) => toggle.setValue(this.plugin.settings.use24Hour).onChange(async (value) => {
      this.plugin.settings.use24Hour = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Blinking colon").setDesc("Make the colon blink every second").addToggle((toggle) => toggle.setValue(this.plugin.settings.blinkingColon).onChange(async (value) => {
      this.plugin.settings.blinkingColon = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Animation" });
    new import_obsidian.Setting(containerEl).setName("Enable animations").setDesc("Show flip animation when digits change").addToggle((toggle) => toggle.setValue(this.plugin.settings.animationEnabled).onChange(async (value) => {
      this.plugin.settings.animationEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Reduce motion").setDesc("Disable animations for accessibility").addToggle((toggle) => toggle.setValue(this.plugin.settings.reduceMotion).onChange(async (value) => {
      this.plugin.settings.reduceMotion = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Sound" });
    new import_obsidian.Setting(containerEl).setName("Enable sound").setDesc("Enable audio feedback").addToggle((toggle) => toggle.setValue(this.plugin.settings.soundEnabled).onChange(async (value) => {
      this.plugin.settings.soundEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Tick sound").setDesc("Play a tick sound on each second").addToggle((toggle) => toggle.setValue(this.plugin.settings.tickSoundEnabled).onChange(async (value) => {
      this.plugin.settings.tickSoundEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Alarm sound").setDesc("Play alarm when timer completes").addToggle((toggle) => toggle.setValue(this.plugin.settings.alarmSoundEnabled).onChange(async (value) => {
      this.plugin.settings.alarmSoundEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Volume").setDesc("Adjust sound volume").addSlider((slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.volume).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.volume = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Timer" });
    new import_obsidian.Setting(containerEl).setName("Loop timer").setDesc("Automatically restart timer when it completes").addToggle((toggle) => toggle.setValue(this.plugin.settings.timerLoop).onChange(async (value) => {
      this.plugin.settings.timerLoop = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Persist timer state").setDesc("Remember timer state after reloading Obsidian").addToggle((toggle) => toggle.setValue(this.plugin.settings.persistTimerState).onChange(async (value) => {
      this.plugin.settings.persistTimerState = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Accessibility" });
    new import_obsidian.Setting(containerEl).setName("High contrast").setDesc("Use high contrast colors for better visibility").addToggle((toggle) => toggle.setValue(this.plugin.settings.highContrast).onChange(async (value) => {
      this.plugin.settings.highContrast = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Unobtrusive Display" });
    new import_obsidian.Setting(containerEl).setName("Show in status bar").setDesc("Display time in the status bar at the bottom (minimal and unobtrusive)").addToggle((toggle) => toggle.setValue(this.plugin.settings.showInStatusBar).onChange(async (value) => {
      this.plugin.settings.showInStatusBar = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.setupStatusBar();
      } else {
        this.plugin.removeStatusBar();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Show floating clock").setDesc("Display a minimal floating clock overlay in your workspace").addToggle((toggle) => toggle.setValue(this.plugin.settings.showFloatingClock).onChange(async (value) => {
      this.plugin.settings.showFloatingClock = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.setupFloatingClock();
      } else {
        this.plugin.removeFloatingClock();
      }
    }));
  }
};
